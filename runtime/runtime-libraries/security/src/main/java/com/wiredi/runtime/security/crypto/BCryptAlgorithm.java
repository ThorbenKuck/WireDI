package com.wiredi.runtime.security.crypto;

import at.favre.lib.crypto.bcrypt.BCrypt;
import at.favre.lib.crypto.bcrypt.LongPasswordStrategies;
import at.favre.lib.crypto.bcrypt.LongPasswordStrategy;
import com.wiredi.runtime.security.crypto.generator.KeyGenerator;
import org.jetbrains.annotations.NotNull;

/**
 * Implementation of the {@link CryptographicAlgorithm} interface that uses the BCrypt algorithm
 * for password hashing and verification.
 *
 * <p>BCrypt is a password-hashing function designed by Niels Provos and David Mazi√®res to safely
 * hash passwords using a computationally intensive algorithm with a configurable work factor.
 * This implementation uses the "at.favre.lib" BCrypt library.</p>
 *
 * <p>Features:</p>
 * <ul>
 *   <li>Configurable cost factor to adjust computational complexity</li>
 *   <li>Secure salt generation using a customizable {@link KeyGenerator}</li>
 *   <li>Support for different BCrypt versions</li>
 *   <li>Configurable long password strategy</li>
 * </ul>
 *
 * <p>Usage example:</p>
 * <pre>{@code
 * // Create with default settings (cost factor 12, version 2A)
 * CryptographicAlgorithm bcrypt = new BCryptAlgorithm();
 *
 * // Create with custom properties
 * BCryptAlgorithm.Properties props = new BCryptAlgorithm.Properties(
 *     14,                                           // Higher cost factor for more security
 *     BCrypt.Version.VERSION_2B,                    // Use version 2B
 *     LongPasswordStrategies.hashSha512(BCrypt.Version.VERSION_2B) // Custom handling for long passwords
 * );
 * CryptographicAlgorithm customBcrypt = new BCryptAlgorithm(props);
 *
 * // Encode a password
 * String encoded = bcrypt.encode("mySecretPassword");
 *
 * // Verify a password
 * boolean isValid = bcrypt.matches("mySecretPassword", encoded);
 * }</pre>
 *
 * @see CryptographicAlgorithm
 * @see KeyGenerator
 * @see <a href="https://en.wikipedia.org/wiki/Bcrypt">BCrypt on Wikipedia</a>
 */
public class BCryptAlgorithm implements CryptographicAlgorithm {

    /**
     * Default properties for BCrypt algorithm with reasonable security settings.
     * Uses:
     * <ul>
     *   <li>Cost factor: 12 (recommended minimum for security as of 2022)</li>
     *   <li>Version: 2A (widely supported version)</li>
     *   <li>Long password strategy: Strict strategy that rejects too long passwords</li>
     * </ul>
     */
    private static final Properties DEFAULT_PROPERTIES = new Properties(12, BCrypt.Version.VERSION_2A, LongPasswordStrategies.strict(BCrypt.Version.VERSION_2A));

    /**
     * Key generator used to create salt values for password hashing.
     */
    private final KeyGenerator keyGenerator;

    /**
     * Properties controlling the BCrypt algorithm behavior.
     */
    private final Properties properties;

    public BCryptAlgorithm() {
        this(KeyGenerator.random(16), DEFAULT_PROPERTIES);
    }

    public BCryptAlgorithm(KeyGenerator keyGenerator) {
        this(keyGenerator, DEFAULT_PROPERTIES);
    }

    public BCryptAlgorithm(Properties properties) {
        this(KeyGenerator.random(16), properties);
    }

    public BCryptAlgorithm(KeyGenerator keyGenerator, Properties properties) {
        this.keyGenerator = keyGenerator;
        this.properties = properties;
    }

    /**
     * Encodes the provided raw password using the BCrypt algorithm.
     * The password is hashed with a salt generated by the configured key generator,
     * using the configured cost factor, version, and long password strategy.
     *
     * @param rawPassword the password to encode
     * @return the BCrypt-encoded password string with algorithm identifier prefix
     * @throws IllegalArgumentException if the raw password is null or invalid
     */
    @Override
    public @NotNull String encode(@NotNull CharSequence rawPassword) {
        BCrypt.Hasher hasher = BCrypt.with(properties.version, properties.longPasswordStrategy);
        byte[] salt = keyGenerator.generateKey();
        return identify(new String(hasher.hash(properties.cost, salt, rawPassword.toString().getBytes())));
    }

    /**
     * Returns the identifier for this algorithm: "bcrypt".
     * <p>
     * This identifier is used in the encoded password format.
     *
     * @return the string "bcrypt"
     */
    @Override
    public @NotNull String identifier() {
        return "bcrypt";
    }

    /**
     * Verifies that the provided raw password matches the encoded password.
     * <p>
     * The method extracts the actual BCrypt hash from the encoded password string
     * (removing the algorithm identifier if present) and checks if it matches
     * the raw password when hashed with the same settings.
     *
     * @param rawPassword     the raw password to verify
     * @param encodedPassword the encoded password to check against
     * @return true if the passwords match, false otherwise
     * @throws IllegalArgumentException if either parameter is null or invalid
     */
    @Override
    public boolean matches(@NotNull CharSequence rawPassword, @NotNull String encodedPassword) {
        BCrypt.Verifyer verifyer = BCrypt.verifyer(properties.version, properties.longPasswordStrategy);
        return verifyer.verify(rawPassword.toString().getBytes(), sanitizeInput(encodedPassword).getBytes()).verified;
    }

    /**
     * Configuration properties for the BCrypt algorithm implementation.
     * Controls the cost factor, version, and handling of long passwords.
     */
    public record Properties(
            /**
             * The work factor for the BCrypt algorithm. Higher values increase security but also
             * computational time.
             *
             * Recommended minimum is 10, with 12+ preferred for sensitive applications.
             * Each increment roughly doubles the computational work required.
             */
            int cost,

            /**
             * The BCrypt version to use. Common versions are 2A, 2B, and 2Y.
             *
             * Different versions have slightly different formats and compatibility considerations.
             */
            BCrypt.Version version,

            /**
             * Strategy for handling passwords that exceed BCrypt's internal length limit.
             *
             * Options include rejection (strict), truncation, or pre-hashing with another algorithm.
             */
            LongPasswordStrategy longPasswordStrategy
    ) {
    }
}
